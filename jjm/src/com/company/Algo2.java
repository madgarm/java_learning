package com.company;

public class Algo2 {

    public static void main(String[] args) {
        // оригинально...
        String[] names = {"Ten", "Eleven", "Two", "Four", "Seven", "Thirteen", "One", "Fourteen", "Three", "Eight", "Nine", "Twelve", "Five", "Six"};
        double[] data = {10.0, 11.0, 2.0, 4.0, 7.0, 13.0, 1.0, 14.0, 3.0, 8.0, 9.0, 12.0, 5.0, 6.0};
        printData(names, data);
        sortSales(names, data);

    }

    private static void printData(String[] names, double[] data) {
        System.out.print("{");
        for (int i = 0; i < names.length; i++) {
            System.out.print(names[i] + ": " + data[i] + ", ");
        }
        System.out.println("\b\b}");
    }

    private static void sortSales(String[] names, double[] data) {
        int m = 0; // служебная переменная-счетчик для проверки на наличие данных в массивах (читай дальше)

        if (names.length != data.length) { // проверка на сопоставимость массивов, длина их должна быть одинакова
            System.out.println("Corrupted Data"); // если нет - выводим "Corrupted Data"
        } else { // если же длина совпадает
            for (int i = 0; i < names.length; i++) { // задаем цикл по массиву названий стран
                if ((names[i] == "") && (data[i] == 0)) { // если под одним и тем же индексом в обоих массивах пусто
                    m += 1; // тогда увеличиваем служебный счетчик на 1
                }
            }
            if (m == names.length) {
                // если счетчик накрутил до значения равного длине массивов, т.е. в каждом значении обоих массивов пусто
                System.out.println("Empty Data"); // выводим "Empty Data"
            }
            // цикл от 0 до длины массива пополам (не включая), т.к. за один проход сортируется 2 элемента
            for (int i = 0; i < data.length / 2; i++) {
                int maxId = i; // служебная переменная для хранения индекса максимального значения
                int minId = i; // служебная переменная для хранения индекса минимального значения
                double max = data[maxId]; // служебная переменная для хранения максимального значения
                double min = data[minId]; // служебная переменная для хранения минимального значения
                // служебная переменная для значения из массива Названий, соответствующего максимальному значения
                String minNames = names[minId];
                // служебная переменная для значения из массива Названий, соответствующего минимальному значения
                String maxNames = names[maxId];
                // внутренний цикл, каждую итерацию сужаем его на 1 слева и справа
                for (int j = i; j < data.length - i; j++) {
                    if (data[j] > max) { // ищем максимальное значение
                        max = data[j]; // записываем в служебную переменную для максимума
                        maxId = j; // запоминаем индекс максимума
                        maxNames = names[j]; // запоминаем соответствующее максимальному значению Название
                    }
                    if (data[j] < min) { // ищем минимальное значение
                        min = data[j]; // записываем в служебную переменную для минимума
                        minId = j; // запоминаем индекс минимума
                        minNames = names[j]; // запоминаем соответствующее минимальному значению Название
                    }
                }
                // проверяем граничное условие: минимальное справа рассматриваемого отрезка, максимальное - слева
                if (minId == data.length - i - 1 && maxId == i) {
                    data[i] = min; // записываем в крайнюю левую позицию минимум
                    names[i] = minNames; // соответствующие изменения в массив Названий
                    data[data.length - i - 1] = max; // записываем в крайнюю правую позицию максимум
                    names[data.length - i - 1] = maxNames; // соответствующие изменения в массив Названий
                // проверяем граничное условие: минимальное справа рассматриваемого отрезка, максимальное - НЕ слева
                } else if (minId == data.length - i - 1 && maxId != i) {
                    data[maxId] = data[i]; // записываем в позицию максимума значение из краней левой позиции
                    names[maxId] = names[i]; // соответствующие изменения в массив Названий
                    data[i] = min; // записываем в крайнюю левую позицию минимум
                    names[i] = minNames; // соответствующие изменения в массив Названий
                    data[data.length - i - 1] = max; // записываем в крайнюю правую позицию максимум
                    names[data.length - i - 1] = maxNames; // соответствующие изменения в массив Названий
                // проверяем граничное условие: минимальное НЕ справа рассматриваемого отрезка, максимальное - слева
                } else if (minId != data.length - i - 1 && maxId == i) {
                    data[i] = min; // записываем в крайнюю левую позицию минимум
                    names[i] = minNames; // соответствующие изменения в массив Названий
                    // записываем в позицию минимума значение из краней правой позиции
                    data[minId] = data[data.length - i - 1];
                    names[minId] = names[data.length - i - 1]; // соответствующие изменения в массив Названий
                    data[data.length - i - 1] = max; // записываем в крайнюю правую позицию максимум
                    names[data.length - i - 1] = maxNames; // соответствующие изменения в массив Названий
                } else { // для всех иных ситуаций
                    data[minId] = data[i]; // записываем в позицию минимума значение из краней левой позиции
                    names[minId] = names[i]; // соответствующие изменения в массив Названий
                    data[i] = min; // записываем в крайнюю левую позицию минимум
                    names[i] = minNames; // соответствующие изменения в массив Названий
                    // записываем в позицию максимума значение из краней правой позиции
                    data[maxId] = data[data.length - i - 1];
                    names[maxId] = names[data.length - i - 1]; // соответствующие изменения в массив Названий
                    data[data.length - i - 1] = max; // записываем в крайнюю правую позицию максимум
                    names[data.length - i - 1] = maxNames; // соответствующие изменения в массив Названий
                }
                printData(names, data); // выводим на каждом пробежке оба массива
            }
            printData(names, data); // в конце выводим оба массива
        }
    }
}

